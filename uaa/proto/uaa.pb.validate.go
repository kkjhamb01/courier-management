// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: uaa.proto

package proto

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
)

// Validate checks the field values on CourierOtpRegisterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CourierOtpRegisterRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CourierOtpRegisterRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDeviceId()) < 1 {
		err := CourierOtpRegisterRequestValidationError{
			field:  "DeviceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPhoneNumber()) < 1 {
		err := CourierOtpRegisterRequestValidationError{
			field:  "PhoneNumber",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Manufacturer

	// no validation rules for DeviceModel

	// no validation rules for DeviceOs

	// no validation rules for DeviceVersion

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return CourierOtpRegisterRequestMultiError(errors)
	}
	return nil
}

// CourierOtpRegisterRequestMultiError is an error wrapping multiple validation
// errors returned by CourierOtpRegisterRequest.Validate(true) if the
// designated constraints aren't met.
type CourierOtpRegisterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourierOtpRegisterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourierOtpRegisterRequestMultiError) AllErrors() []error { return m }

// CourierOtpRegisterRequestValidationError is the validation error returned by
// CourierOtpRegisterRequest.Validate if the designated constraints aren't met.
type CourierOtpRegisterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourierOtpRegisterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourierOtpRegisterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourierOtpRegisterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourierOtpRegisterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourierOtpRegisterRequestValidationError) ErrorName() string {
	return "CourierOtpRegisterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CourierOtpRegisterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourierOtpRegisterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourierOtpRegisterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourierOtpRegisterRequestValidationError{}

// Validate checks the field values on CourierOtpRegisterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CourierOtpRegisterResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CourierOtpRegisterResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CourierOtpRegisterResponseMultiError(errors)
	}
	return nil
}

// CourierOtpRegisterResponseMultiError is an error wrapping multiple
// validation errors returned by CourierOtpRegisterResponse.Validate(true) if
// the designated constraints aren't met.
type CourierOtpRegisterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourierOtpRegisterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourierOtpRegisterResponseMultiError) AllErrors() []error { return m }

// CourierOtpRegisterResponseValidationError is the validation error returned
// by CourierOtpRegisterResponse.Validate if the designated constraints aren't met.
type CourierOtpRegisterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourierOtpRegisterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourierOtpRegisterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourierOtpRegisterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourierOtpRegisterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourierOtpRegisterResponseValidationError) ErrorName() string {
	return "CourierOtpRegisterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CourierOtpRegisterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourierOtpRegisterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourierOtpRegisterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourierOtpRegisterResponseValidationError{}

// Validate checks the field values on CourierOtpReclaimRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CourierOtpReclaimRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CourierOtpReclaimRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDeviceId()) < 1 {
		err := CourierOtpReclaimRequestValidationError{
			field:  "DeviceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPhoneNumber()) < 1 {
		err := CourierOtpReclaimRequestValidationError{
			field:  "PhoneNumber",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetOldPhoneNumber()) < 1 {
		err := CourierOtpReclaimRequestValidationError{
			field:  "OldPhoneNumber",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Manufacturer

	// no validation rules for DeviceModel

	// no validation rules for DeviceOs

	// no validation rules for DeviceVersion

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return CourierOtpReclaimRequestMultiError(errors)
	}
	return nil
}

// CourierOtpReclaimRequestMultiError is an error wrapping multiple validation
// errors returned by CourierOtpReclaimRequest.Validate(true) if the
// designated constraints aren't met.
type CourierOtpReclaimRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourierOtpReclaimRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourierOtpReclaimRequestMultiError) AllErrors() []error { return m }

// CourierOtpReclaimRequestValidationError is the validation error returned by
// CourierOtpReclaimRequest.Validate if the designated constraints aren't met.
type CourierOtpReclaimRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourierOtpReclaimRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourierOtpReclaimRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourierOtpReclaimRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourierOtpReclaimRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourierOtpReclaimRequestValidationError) ErrorName() string {
	return "CourierOtpReclaimRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CourierOtpReclaimRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourierOtpReclaimRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourierOtpReclaimRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourierOtpReclaimRequestValidationError{}

// Validate checks the field values on CourierOtpReclaimResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CourierOtpReclaimResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CourierOtpReclaimResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CourierOtpReclaimResponseMultiError(errors)
	}
	return nil
}

// CourierOtpReclaimResponseMultiError is an error wrapping multiple validation
// errors returned by CourierOtpReclaimResponse.Validate(true) if the
// designated constraints aren't met.
type CourierOtpReclaimResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourierOtpReclaimResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourierOtpReclaimResponseMultiError) AllErrors() []error { return m }

// CourierOtpReclaimResponseValidationError is the validation error returned by
// CourierOtpReclaimResponse.Validate if the designated constraints aren't met.
type CourierOtpReclaimResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourierOtpReclaimResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourierOtpReclaimResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourierOtpReclaimResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourierOtpReclaimResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourierOtpReclaimResponseValidationError) ErrorName() string {
	return "CourierOtpReclaimResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CourierOtpReclaimResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourierOtpReclaimResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourierOtpReclaimResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourierOtpReclaimResponseValidationError{}

// Validate checks the field values on CourierOtpLoginRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CourierOtpLoginRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CourierOtpLoginRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDeviceId()) < 1 {
		err := CourierOtpLoginRequestValidationError{
			field:  "DeviceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPhoneNumber()) < 1 {
		err := CourierOtpLoginRequestValidationError{
			field:  "PhoneNumber",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CourierOtpLoginRequestMultiError(errors)
	}
	return nil
}

// CourierOtpLoginRequestMultiError is an error wrapping multiple validation
// errors returned by CourierOtpLoginRequest.Validate(true) if the designated
// constraints aren't met.
type CourierOtpLoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourierOtpLoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourierOtpLoginRequestMultiError) AllErrors() []error { return m }

// CourierOtpLoginRequestValidationError is the validation error returned by
// CourierOtpLoginRequest.Validate if the designated constraints aren't met.
type CourierOtpLoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourierOtpLoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourierOtpLoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourierOtpLoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourierOtpLoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourierOtpLoginRequestValidationError) ErrorName() string {
	return "CourierOtpLoginRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CourierOtpLoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourierOtpLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourierOtpLoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourierOtpLoginRequestValidationError{}

// Validate checks the field values on CourierOtpLoginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CourierOtpLoginResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CourierOtpLoginResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CourierOtpLoginResponseMultiError(errors)
	}
	return nil
}

// CourierOtpLoginResponseMultiError is an error wrapping multiple validation
// errors returned by CourierOtpLoginResponse.Validate(true) if the designated
// constraints aren't met.
type CourierOtpLoginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourierOtpLoginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourierOtpLoginResponseMultiError) AllErrors() []error { return m }

// CourierOtpLoginResponseValidationError is the validation error returned by
// CourierOtpLoginResponse.Validate if the designated constraints aren't met.
type CourierOtpLoginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourierOtpLoginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourierOtpLoginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourierOtpLoginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourierOtpLoginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourierOtpLoginResponseValidationError) ErrorName() string {
	return "CourierOtpLoginResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CourierOtpLoginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourierOtpLoginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourierOtpLoginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourierOtpLoginResponseValidationError{}

// Validate checks the field values on CourierOtpAuthenticateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CourierOtpAuthenticateRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CourierOtpAuthenticateRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDeviceId()) < 1 {
		err := CourierOtpAuthenticateRequestValidationError{
			field:  "DeviceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := len(m.GetCredentials()); l < 1 || l > 2 {
		err := CourierOtpAuthenticateRequestValidationError{
			field:  "Credentials",
			reason: "value must contain between 1 and 2 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetCredentials() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = CourierOtpAuthenticateRequestValidationError{
					field:  fmt.Sprintf("Credentials[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return CourierOtpAuthenticateRequestMultiError(errors)
	}
	return nil
}

// CourierOtpAuthenticateRequestMultiError is an error wrapping multiple
// validation errors returned by CourierOtpAuthenticateRequest.Validate(true)
// if the designated constraints aren't met.
type CourierOtpAuthenticateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourierOtpAuthenticateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourierOtpAuthenticateRequestMultiError) AllErrors() []error { return m }

// CourierOtpAuthenticateRequestValidationError is the validation error
// returned by CourierOtpAuthenticateRequest.Validate if the designated
// constraints aren't met.
type CourierOtpAuthenticateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourierOtpAuthenticateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourierOtpAuthenticateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourierOtpAuthenticateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourierOtpAuthenticateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourierOtpAuthenticateRequestValidationError) ErrorName() string {
	return "CourierOtpAuthenticateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CourierOtpAuthenticateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourierOtpAuthenticateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourierOtpAuthenticateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourierOtpAuthenticateRequestValidationError{}

// Validate checks the field values on CourierOtpAuthenticateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CourierOtpAuthenticateResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CourierOtpAuthenticateResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RemainingRetryCount

	if v, ok := interface{}(m.GetToken()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CourierOtpAuthenticateResponseValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return CourierOtpAuthenticateResponseMultiError(errors)
	}
	return nil
}

// CourierOtpAuthenticateResponseMultiError is an error wrapping multiple
// validation errors returned by CourierOtpAuthenticateResponse.Validate(true)
// if the designated constraints aren't met.
type CourierOtpAuthenticateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourierOtpAuthenticateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourierOtpAuthenticateResponseMultiError) AllErrors() []error { return m }

// CourierOtpAuthenticateResponseValidationError is the validation error
// returned by CourierOtpAuthenticateResponse.Validate if the designated
// constraints aren't met.
type CourierOtpAuthenticateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourierOtpAuthenticateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourierOtpAuthenticateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourierOtpAuthenticateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourierOtpAuthenticateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourierOtpAuthenticateResponseValidationError) ErrorName() string {
	return "CourierOtpAuthenticateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CourierOtpAuthenticateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourierOtpAuthenticateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourierOtpAuthenticateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourierOtpAuthenticateResponseValidationError{}

// Validate checks the field values on Credential with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// CredentialMultiError, or nil if none found. Otherwise, only the first error
// is returned, if any.
func (m *Credential) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Value

	if len(errors) > 0 {
		return CredentialMultiError(errors)
	}
	return nil
}

// CredentialMultiError is an error wrapping multiple validation errors
// returned by Credential.Validate(true) if the designated constraints aren't met.
type CredentialMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CredentialMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CredentialMultiError) AllErrors() []error { return m }

// CredentialValidationError is the validation error returned by
// Credential.Validate if the designated constraints aren't met.
type CredentialValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CredentialValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CredentialValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CredentialValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CredentialValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CredentialValidationError) ErrorName() string { return "CredentialValidationError" }

// Error satisfies the builtin error interface
func (e CredentialValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCredential.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CredentialValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CredentialValidationError{}

// Validate checks the field values on CourierOtpRetryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CourierOtpRetryRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CourierOtpRetryRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDeviceId()) < 1 {
		err := CourierOtpRetryRequestValidationError{
			field:  "DeviceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPhoneNumber()) < 1 {
		err := CourierOtpRetryRequestValidationError{
			field:  "PhoneNumber",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CourierOtpRetryRequestMultiError(errors)
	}
	return nil
}

// CourierOtpRetryRequestMultiError is an error wrapping multiple validation
// errors returned by CourierOtpRetryRequest.Validate(true) if the designated
// constraints aren't met.
type CourierOtpRetryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourierOtpRetryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourierOtpRetryRequestMultiError) AllErrors() []error { return m }

// CourierOtpRetryRequestValidationError is the validation error returned by
// CourierOtpRetryRequest.Validate if the designated constraints aren't met.
type CourierOtpRetryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourierOtpRetryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourierOtpRetryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourierOtpRetryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourierOtpRetryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourierOtpRetryRequestValidationError) ErrorName() string {
	return "CourierOtpRetryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CourierOtpRetryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourierOtpRetryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourierOtpRetryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourierOtpRetryRequestValidationError{}

// Validate checks the field values on CourierOtpRetryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CourierOtpRetryResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CourierOtpRetryResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CourierOtpRetryResponseMultiError(errors)
	}
	return nil
}

// CourierOtpRetryResponseMultiError is an error wrapping multiple validation
// errors returned by CourierOtpRetryResponse.Validate(true) if the designated
// constraints aren't met.
type CourierOtpRetryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourierOtpRetryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourierOtpRetryResponseMultiError) AllErrors() []error { return m }

// CourierOtpRetryResponseValidationError is the validation error returned by
// CourierOtpRetryResponse.Validate if the designated constraints aren't met.
type CourierOtpRetryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourierOtpRetryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourierOtpRetryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourierOtpRetryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourierOtpRetryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourierOtpRetryResponseValidationError) ErrorName() string {
	return "CourierOtpRetryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CourierOtpRetryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourierOtpRetryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourierOtpRetryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourierOtpRetryResponseValidationError{}

// Validate checks the field values on CourierOauthRegisterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CourierOauthRegisterRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CourierOauthRegisterRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAccessToken()) < 1 {
		err := CourierOauthRegisterRequestValidationError{
			field:  "AccessToken",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDeviceId()) < 1 {
		err := CourierOauthRegisterRequestValidationError{
			field:  "DeviceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := OauthType_name[int32(m.GetOauthType())]; !ok {
		err := CourierOauthRegisterRequestValidationError{
			field:  "OauthType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CourierOauthRegisterRequestMultiError(errors)
	}
	return nil
}

// CourierOauthRegisterRequestMultiError is an error wrapping multiple
// validation errors returned by CourierOauthRegisterRequest.Validate(true) if
// the designated constraints aren't met.
type CourierOauthRegisterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourierOauthRegisterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourierOauthRegisterRequestMultiError) AllErrors() []error { return m }

// CourierOauthRegisterRequestValidationError is the validation error returned
// by CourierOauthRegisterRequest.Validate if the designated constraints
// aren't met.
type CourierOauthRegisterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourierOauthRegisterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourierOauthRegisterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourierOauthRegisterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourierOauthRegisterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourierOauthRegisterRequestValidationError) ErrorName() string {
	return "CourierOauthRegisterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CourierOauthRegisterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourierOauthRegisterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourierOauthRegisterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourierOauthRegisterRequestValidationError{}

// Validate checks the field values on CourierOauthRegisterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CourierOauthRegisterResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CourierOauthRegisterResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FollowLink

	if len(errors) > 0 {
		return CourierOauthRegisterResponseMultiError(errors)
	}
	return nil
}

// CourierOauthRegisterResponseMultiError is an error wrapping multiple
// validation errors returned by CourierOauthRegisterResponse.Validate(true)
// if the designated constraints aren't met.
type CourierOauthRegisterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourierOauthRegisterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourierOauthRegisterResponseMultiError) AllErrors() []error { return m }

// CourierOauthRegisterResponseValidationError is the validation error returned
// by CourierOauthRegisterResponse.Validate if the designated constraints
// aren't met.
type CourierOauthRegisterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourierOauthRegisterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourierOauthRegisterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourierOauthRegisterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourierOauthRegisterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourierOauthRegisterResponseValidationError) ErrorName() string {
	return "CourierOauthRegisterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CourierOauthRegisterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourierOauthRegisterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourierOauthRegisterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourierOauthRegisterResponseValidationError{}

// Validate checks the field values on CourierOauthRegisterVerifyRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in CourierOauthRegisterVerifyRequestMultiError, or
// nil if none found. Otherwise, only the first error is returned, if any.
func (m *CourierOauthRegisterVerifyRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDeviceId()) < 1 {
		err := CourierOauthRegisterVerifyRequestValidationError{
			field:  "DeviceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCode()) < 1 {
		err := CourierOauthRegisterVerifyRequestValidationError{
			field:  "Code",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CourierOauthRegisterVerifyRequestMultiError(errors)
	}
	return nil
}

// CourierOauthRegisterVerifyRequestMultiError is an error wrapping multiple
// validation errors returned by
// CourierOauthRegisterVerifyRequest.Validate(true) if the designated
// constraints aren't met.
type CourierOauthRegisterVerifyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourierOauthRegisterVerifyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourierOauthRegisterVerifyRequestMultiError) AllErrors() []error { return m }

// CourierOauthRegisterVerifyRequestValidationError is the validation error
// returned by CourierOauthRegisterVerifyRequest.Validate if the designated
// constraints aren't met.
type CourierOauthRegisterVerifyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourierOauthRegisterVerifyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourierOauthRegisterVerifyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourierOauthRegisterVerifyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourierOauthRegisterVerifyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourierOauthRegisterVerifyRequestValidationError) ErrorName() string {
	return "CourierOauthRegisterVerifyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CourierOauthRegisterVerifyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourierOauthRegisterVerifyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourierOauthRegisterVerifyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourierOauthRegisterVerifyRequestValidationError{}

// Validate checks the field values on CourierOauthRegisterVerifyResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in CourierOauthRegisterVerifyResponseMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *CourierOauthRegisterVerifyResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetInfo()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CourierOauthRegisterVerifyResponseValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return CourierOauthRegisterVerifyResponseMultiError(errors)
	}
	return nil
}

// CourierOauthRegisterVerifyResponseMultiError is an error wrapping multiple
// validation errors returned by
// CourierOauthRegisterVerifyResponse.Validate(true) if the designated
// constraints aren't met.
type CourierOauthRegisterVerifyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourierOauthRegisterVerifyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourierOauthRegisterVerifyResponseMultiError) AllErrors() []error { return m }

// CourierOauthRegisterVerifyResponseValidationError is the validation error
// returned by CourierOauthRegisterVerifyResponse.Validate if the designated
// constraints aren't met.
type CourierOauthRegisterVerifyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourierOauthRegisterVerifyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourierOauthRegisterVerifyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourierOauthRegisterVerifyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourierOauthRegisterVerifyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourierOauthRegisterVerifyResponseValidationError) ErrorName() string {
	return "CourierOauthRegisterVerifyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CourierOauthRegisterVerifyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourierOauthRegisterVerifyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourierOauthRegisterVerifyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourierOauthRegisterVerifyResponseValidationError{}

// Validate checks the field values on CourierOauthLoginRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CourierOauthLoginRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CourierOauthLoginRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDeviceId()) < 1 {
		err := CourierOauthLoginRequestValidationError{
			field:  "DeviceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := OauthType_name[int32(m.GetOauthType())]; !ok {
		err := CourierOauthLoginRequestValidationError{
			field:  "OauthType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CourierOauthLoginRequestMultiError(errors)
	}
	return nil
}

// CourierOauthLoginRequestMultiError is an error wrapping multiple validation
// errors returned by CourierOauthLoginRequest.Validate(true) if the
// designated constraints aren't met.
type CourierOauthLoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourierOauthLoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourierOauthLoginRequestMultiError) AllErrors() []error { return m }

// CourierOauthLoginRequestValidationError is the validation error returned by
// CourierOauthLoginRequest.Validate if the designated constraints aren't met.
type CourierOauthLoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourierOauthLoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourierOauthLoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourierOauthLoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourierOauthLoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourierOauthLoginRequestValidationError) ErrorName() string {
	return "CourierOauthLoginRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CourierOauthLoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourierOauthLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourierOauthLoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourierOauthLoginRequestValidationError{}

// Validate checks the field values on CourierOauthLoginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CourierOauthLoginResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CourierOauthLoginResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FollowLink

	if len(errors) > 0 {
		return CourierOauthLoginResponseMultiError(errors)
	}
	return nil
}

// CourierOauthLoginResponseMultiError is an error wrapping multiple validation
// errors returned by CourierOauthLoginResponse.Validate(true) if the
// designated constraints aren't met.
type CourierOauthLoginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourierOauthLoginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourierOauthLoginResponseMultiError) AllErrors() []error { return m }

// CourierOauthLoginResponseValidationError is the validation error returned by
// CourierOauthLoginResponse.Validate if the designated constraints aren't met.
type CourierOauthLoginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourierOauthLoginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourierOauthLoginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourierOauthLoginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourierOauthLoginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourierOauthLoginResponseValidationError) ErrorName() string {
	return "CourierOauthLoginResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CourierOauthLoginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourierOauthLoginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourierOauthLoginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourierOauthLoginResponseValidationError{}

// Validate checks the field values on CourierOauthLoginVerifyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CourierOauthLoginVerifyRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CourierOauthLoginVerifyRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDeviceId()) < 1 {
		err := CourierOauthLoginVerifyRequestValidationError{
			field:  "DeviceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCode()) < 1 {
		err := CourierOauthLoginVerifyRequestValidationError{
			field:  "Code",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CourierOauthLoginVerifyRequestMultiError(errors)
	}
	return nil
}

// CourierOauthLoginVerifyRequestMultiError is an error wrapping multiple
// validation errors returned by CourierOauthLoginVerifyRequest.Validate(true)
// if the designated constraints aren't met.
type CourierOauthLoginVerifyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourierOauthLoginVerifyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourierOauthLoginVerifyRequestMultiError) AllErrors() []error { return m }

// CourierOauthLoginVerifyRequestValidationError is the validation error
// returned by CourierOauthLoginVerifyRequest.Validate if the designated
// constraints aren't met.
type CourierOauthLoginVerifyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourierOauthLoginVerifyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourierOauthLoginVerifyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourierOauthLoginVerifyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourierOauthLoginVerifyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourierOauthLoginVerifyRequestValidationError) ErrorName() string {
	return "CourierOauthLoginVerifyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CourierOauthLoginVerifyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourierOauthLoginVerifyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourierOauthLoginVerifyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourierOauthLoginVerifyRequestValidationError{}

// Validate checks the field values on CourierOauthLoginVerifyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CourierOauthLoginVerifyResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CourierOauthLoginVerifyResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetToken()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CourierOauthLoginVerifyResponseValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetInfo()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CourierOauthLoginVerifyResponseValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return CourierOauthLoginVerifyResponseMultiError(errors)
	}
	return nil
}

// CourierOauthLoginVerifyResponseMultiError is an error wrapping multiple
// validation errors returned by
// CourierOauthLoginVerifyResponse.Validate(true) if the designated
// constraints aren't met.
type CourierOauthLoginVerifyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourierOauthLoginVerifyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourierOauthLoginVerifyResponseMultiError) AllErrors() []error { return m }

// CourierOauthLoginVerifyResponseValidationError is the validation error
// returned by CourierOauthLoginVerifyResponse.Validate if the designated
// constraints aren't met.
type CourierOauthLoginVerifyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourierOauthLoginVerifyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourierOauthLoginVerifyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourierOauthLoginVerifyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourierOauthLoginVerifyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourierOauthLoginVerifyResponseValidationError) ErrorName() string {
	return "CourierOauthLoginVerifyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CourierOauthLoginVerifyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourierOauthLoginVerifyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourierOauthLoginVerifyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourierOauthLoginVerifyResponseValidationError{}

// Validate checks the field values on UserOauthInfo with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// UserOauthInfoMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *UserOauthInfo) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Email

	// no validation rules for FirstName

	// no validation rules for LastName

	if len(errors) > 0 {
		return UserOauthInfoMultiError(errors)
	}
	return nil
}

// UserOauthInfoMultiError is an error wrapping multiple validation errors
// returned by UserOauthInfo.Validate(true) if the designated constraints
// aren't met.
type UserOauthInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOauthInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOauthInfoMultiError) AllErrors() []error { return m }

// UserOauthInfoValidationError is the validation error returned by
// UserOauthInfo.Validate if the designated constraints aren't met.
type UserOauthInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOauthInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOauthInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOauthInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOauthInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOauthInfoValidationError) ErrorName() string { return "UserOauthInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserOauthInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOauthInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOauthInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOauthInfoValidationError{}

// Validate checks the field values on UserOauthRegisterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UserOauthRegisterRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UserOauthRegisterRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	if utf8.RuneCountInString(m.GetDeviceId()) < 1 {
		err := UserOauthRegisterRequestValidationError{
			field:  "DeviceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := OauthType_name[int32(m.GetOauthType())]; !ok {
		err := UserOauthRegisterRequestValidationError{
			field:  "OauthType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserOauthRegisterRequestMultiError(errors)
	}
	return nil
}

// UserOauthRegisterRequestMultiError is an error wrapping multiple validation
// errors returned by UserOauthRegisterRequest.Validate(true) if the
// designated constraints aren't met.
type UserOauthRegisterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOauthRegisterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOauthRegisterRequestMultiError) AllErrors() []error { return m }

// UserOauthRegisterRequestValidationError is the validation error returned by
// UserOauthRegisterRequest.Validate if the designated constraints aren't met.
type UserOauthRegisterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOauthRegisterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOauthRegisterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOauthRegisterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOauthRegisterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOauthRegisterRequestValidationError) ErrorName() string {
	return "UserOauthRegisterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UserOauthRegisterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOauthRegisterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOauthRegisterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOauthRegisterRequestValidationError{}

// Validate checks the field values on UserOauthRegisterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UserOauthRegisterResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UserOauthRegisterResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FollowLink

	if len(errors) > 0 {
		return UserOauthRegisterResponseMultiError(errors)
	}
	return nil
}

// UserOauthRegisterResponseMultiError is an error wrapping multiple validation
// errors returned by UserOauthRegisterResponse.Validate(true) if the
// designated constraints aren't met.
type UserOauthRegisterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOauthRegisterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOauthRegisterResponseMultiError) AllErrors() []error { return m }

// UserOauthRegisterResponseValidationError is the validation error returned by
// UserOauthRegisterResponse.Validate if the designated constraints aren't met.
type UserOauthRegisterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOauthRegisterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOauthRegisterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOauthRegisterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOauthRegisterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOauthRegisterResponseValidationError) ErrorName() string {
	return "UserOauthRegisterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UserOauthRegisterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOauthRegisterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOauthRegisterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOauthRegisterResponseValidationError{}

// Validate checks the field values on UserOauthRegisterVerifyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UserOauthRegisterVerifyRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UserOauthRegisterVerifyRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDeviceId()) < 1 {
		err := UserOauthRegisterVerifyRequestValidationError{
			field:  "DeviceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCode()) < 1 {
		err := UserOauthRegisterVerifyRequestValidationError{
			field:  "Code",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserOauthRegisterVerifyRequestMultiError(errors)
	}
	return nil
}

// UserOauthRegisterVerifyRequestMultiError is an error wrapping multiple
// validation errors returned by UserOauthRegisterVerifyRequest.Validate(true)
// if the designated constraints aren't met.
type UserOauthRegisterVerifyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOauthRegisterVerifyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOauthRegisterVerifyRequestMultiError) AllErrors() []error { return m }

// UserOauthRegisterVerifyRequestValidationError is the validation error
// returned by UserOauthRegisterVerifyRequest.Validate if the designated
// constraints aren't met.
type UserOauthRegisterVerifyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOauthRegisterVerifyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOauthRegisterVerifyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOauthRegisterVerifyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOauthRegisterVerifyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOauthRegisterVerifyRequestValidationError) ErrorName() string {
	return "UserOauthRegisterVerifyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UserOauthRegisterVerifyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOauthRegisterVerifyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOauthRegisterVerifyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOauthRegisterVerifyRequestValidationError{}

// Validate checks the field values on UserOauthRegisterVerifyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UserOauthRegisterVerifyResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UserOauthRegisterVerifyResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetToken()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = UserOauthRegisterVerifyResponseValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetInfo()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = UserOauthRegisterVerifyResponseValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return UserOauthRegisterVerifyResponseMultiError(errors)
	}
	return nil
}

// UserOauthRegisterVerifyResponseMultiError is an error wrapping multiple
// validation errors returned by
// UserOauthRegisterVerifyResponse.Validate(true) if the designated
// constraints aren't met.
type UserOauthRegisterVerifyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOauthRegisterVerifyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOauthRegisterVerifyResponseMultiError) AllErrors() []error { return m }

// UserOauthRegisterVerifyResponseValidationError is the validation error
// returned by UserOauthRegisterVerifyResponse.Validate if the designated
// constraints aren't met.
type UserOauthRegisterVerifyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOauthRegisterVerifyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOauthRegisterVerifyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOauthRegisterVerifyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOauthRegisterVerifyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOauthRegisterVerifyResponseValidationError) ErrorName() string {
	return "UserOauthRegisterVerifyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UserOauthRegisterVerifyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOauthRegisterVerifyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOauthRegisterVerifyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOauthRegisterVerifyResponseValidationError{}

// Validate checks the field values on UserOauthLoginRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UserOauthLoginRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UserOauthLoginRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDeviceId()) < 1 {
		err := UserOauthLoginRequestValidationError{
			field:  "DeviceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := OauthType_name[int32(m.GetOauthType())]; !ok {
		err := UserOauthLoginRequestValidationError{
			field:  "OauthType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserOauthLoginRequestMultiError(errors)
	}
	return nil
}

// UserOauthLoginRequestMultiError is an error wrapping multiple validation
// errors returned by UserOauthLoginRequest.Validate(true) if the designated
// constraints aren't met.
type UserOauthLoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOauthLoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOauthLoginRequestMultiError) AllErrors() []error { return m }

// UserOauthLoginRequestValidationError is the validation error returned by
// UserOauthLoginRequest.Validate if the designated constraints aren't met.
type UserOauthLoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOauthLoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOauthLoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOauthLoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOauthLoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOauthLoginRequestValidationError) ErrorName() string {
	return "UserOauthLoginRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UserOauthLoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOauthLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOauthLoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOauthLoginRequestValidationError{}

// Validate checks the field values on UserOauthLoginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UserOauthLoginResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UserOauthLoginResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FollowLink

	if len(errors) > 0 {
		return UserOauthLoginResponseMultiError(errors)
	}
	return nil
}

// UserOauthLoginResponseMultiError is an error wrapping multiple validation
// errors returned by UserOauthLoginResponse.Validate(true) if the designated
// constraints aren't met.
type UserOauthLoginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOauthLoginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOauthLoginResponseMultiError) AllErrors() []error { return m }

// UserOauthLoginResponseValidationError is the validation error returned by
// UserOauthLoginResponse.Validate if the designated constraints aren't met.
type UserOauthLoginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOauthLoginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOauthLoginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOauthLoginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOauthLoginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOauthLoginResponseValidationError) ErrorName() string {
	return "UserOauthLoginResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UserOauthLoginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOauthLoginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOauthLoginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOauthLoginResponseValidationError{}

// Validate checks the field values on UserOauthLoginVerifyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UserOauthLoginVerifyRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UserOauthLoginVerifyRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDeviceId()) < 1 {
		err := UserOauthLoginVerifyRequestValidationError{
			field:  "DeviceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCode()) < 1 {
		err := UserOauthLoginVerifyRequestValidationError{
			field:  "Code",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserOauthLoginVerifyRequestMultiError(errors)
	}
	return nil
}

// UserOauthLoginVerifyRequestMultiError is an error wrapping multiple
// validation errors returned by UserOauthLoginVerifyRequest.Validate(true) if
// the designated constraints aren't met.
type UserOauthLoginVerifyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOauthLoginVerifyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOauthLoginVerifyRequestMultiError) AllErrors() []error { return m }

// UserOauthLoginVerifyRequestValidationError is the validation error returned
// by UserOauthLoginVerifyRequest.Validate if the designated constraints
// aren't met.
type UserOauthLoginVerifyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOauthLoginVerifyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOauthLoginVerifyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOauthLoginVerifyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOauthLoginVerifyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOauthLoginVerifyRequestValidationError) ErrorName() string {
	return "UserOauthLoginVerifyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UserOauthLoginVerifyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOauthLoginVerifyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOauthLoginVerifyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOauthLoginVerifyRequestValidationError{}

// Validate checks the field values on UserOauthLoginVerifyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UserOauthLoginVerifyResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UserOauthLoginVerifyResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetToken()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = UserOauthLoginVerifyResponseValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetInfo()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = UserOauthLoginVerifyResponseValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return UserOauthLoginVerifyResponseMultiError(errors)
	}
	return nil
}

// UserOauthLoginVerifyResponseMultiError is an error wrapping multiple
// validation errors returned by UserOauthLoginVerifyResponse.Validate(true)
// if the designated constraints aren't met.
type UserOauthLoginVerifyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOauthLoginVerifyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOauthLoginVerifyResponseMultiError) AllErrors() []error { return m }

// UserOauthLoginVerifyResponseValidationError is the validation error returned
// by UserOauthLoginVerifyResponse.Validate if the designated constraints
// aren't met.
type UserOauthLoginVerifyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOauthLoginVerifyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOauthLoginVerifyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOauthLoginVerifyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOauthLoginVerifyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOauthLoginVerifyResponseValidationError) ErrorName() string {
	return "UserOauthLoginVerifyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UserOauthLoginVerifyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOauthLoginVerifyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOauthLoginVerifyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOauthLoginVerifyResponseValidationError{}

// Validate checks the field values on UserOtpRegisterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UserOtpRegisterRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UserOtpRegisterRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	if utf8.RuneCountInString(m.GetDeviceId()) < 1 {
		err := UserOtpRegisterRequestValidationError{
			field:  "DeviceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPhoneNumber()) < 1 {
		err := UserOtpRegisterRequestValidationError{
			field:  "PhoneNumber",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Manufacturer

	// no validation rules for DeviceModel

	// no validation rules for DeviceOs

	// no validation rules for DeviceVersion

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return UserOtpRegisterRequestMultiError(errors)
	}
	return nil
}

// UserOtpRegisterRequestMultiError is an error wrapping multiple validation
// errors returned by UserOtpRegisterRequest.Validate(true) if the designated
// constraints aren't met.
type UserOtpRegisterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOtpRegisterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOtpRegisterRequestMultiError) AllErrors() []error { return m }

// UserOtpRegisterRequestValidationError is the validation error returned by
// UserOtpRegisterRequest.Validate if the designated constraints aren't met.
type UserOtpRegisterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOtpRegisterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOtpRegisterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOtpRegisterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOtpRegisterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOtpRegisterRequestValidationError) ErrorName() string {
	return "UserOtpRegisterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UserOtpRegisterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOtpRegisterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOtpRegisterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOtpRegisterRequestValidationError{}

// Validate checks the field values on UserOtpRegisterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UserOtpRegisterResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UserOtpRegisterResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserOtpRegisterResponseMultiError(errors)
	}
	return nil
}

// UserOtpRegisterResponseMultiError is an error wrapping multiple validation
// errors returned by UserOtpRegisterResponse.Validate(true) if the designated
// constraints aren't met.
type UserOtpRegisterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOtpRegisterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOtpRegisterResponseMultiError) AllErrors() []error { return m }

// UserOtpRegisterResponseValidationError is the validation error returned by
// UserOtpRegisterResponse.Validate if the designated constraints aren't met.
type UserOtpRegisterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOtpRegisterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOtpRegisterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOtpRegisterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOtpRegisterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOtpRegisterResponseValidationError) ErrorName() string {
	return "UserOtpRegisterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UserOtpRegisterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOtpRegisterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOtpRegisterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOtpRegisterResponseValidationError{}

// Validate checks the field values on UserOtpReclaimRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UserOtpReclaimRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UserOtpReclaimRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDeviceId()) < 1 {
		err := UserOtpReclaimRequestValidationError{
			field:  "DeviceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPhoneNumber()) < 1 {
		err := UserOtpReclaimRequestValidationError{
			field:  "PhoneNumber",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetOldPhoneNumber()) < 1 {
		err := UserOtpReclaimRequestValidationError{
			field:  "OldPhoneNumber",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Manufacturer

	// no validation rules for DeviceModel

	// no validation rules for DeviceOs

	// no validation rules for DeviceVersion

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return UserOtpReclaimRequestMultiError(errors)
	}
	return nil
}

// UserOtpReclaimRequestMultiError is an error wrapping multiple validation
// errors returned by UserOtpReclaimRequest.Validate(true) if the designated
// constraints aren't met.
type UserOtpReclaimRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOtpReclaimRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOtpReclaimRequestMultiError) AllErrors() []error { return m }

// UserOtpReclaimRequestValidationError is the validation error returned by
// UserOtpReclaimRequest.Validate if the designated constraints aren't met.
type UserOtpReclaimRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOtpReclaimRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOtpReclaimRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOtpReclaimRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOtpReclaimRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOtpReclaimRequestValidationError) ErrorName() string {
	return "UserOtpReclaimRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UserOtpReclaimRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOtpReclaimRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOtpReclaimRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOtpReclaimRequestValidationError{}

// Validate checks the field values on UserOtpReclaimResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UserOtpReclaimResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UserOtpReclaimResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserOtpReclaimResponseMultiError(errors)
	}
	return nil
}

// UserOtpReclaimResponseMultiError is an error wrapping multiple validation
// errors returned by UserOtpReclaimResponse.Validate(true) if the designated
// constraints aren't met.
type UserOtpReclaimResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOtpReclaimResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOtpReclaimResponseMultiError) AllErrors() []error { return m }

// UserOtpReclaimResponseValidationError is the validation error returned by
// UserOtpReclaimResponse.Validate if the designated constraints aren't met.
type UserOtpReclaimResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOtpReclaimResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOtpReclaimResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOtpReclaimResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOtpReclaimResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOtpReclaimResponseValidationError) ErrorName() string {
	return "UserOtpReclaimResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UserOtpReclaimResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOtpReclaimResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOtpReclaimResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOtpReclaimResponseValidationError{}

// Validate checks the field values on UserOtpLoginRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UserOtpLoginRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UserOtpLoginRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDeviceId()) < 1 {
		err := UserOtpLoginRequestValidationError{
			field:  "DeviceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPhoneNumber()) < 1 {
		err := UserOtpLoginRequestValidationError{
			field:  "PhoneNumber",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserOtpLoginRequestMultiError(errors)
	}
	return nil
}

// UserOtpLoginRequestMultiError is an error wrapping multiple validation
// errors returned by UserOtpLoginRequest.Validate(true) if the designated
// constraints aren't met.
type UserOtpLoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOtpLoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOtpLoginRequestMultiError) AllErrors() []error { return m }

// UserOtpLoginRequestValidationError is the validation error returned by
// UserOtpLoginRequest.Validate if the designated constraints aren't met.
type UserOtpLoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOtpLoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOtpLoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOtpLoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOtpLoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOtpLoginRequestValidationError) ErrorName() string {
	return "UserOtpLoginRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UserOtpLoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOtpLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOtpLoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOtpLoginRequestValidationError{}

// Validate checks the field values on UserOtpLoginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UserOtpLoginResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UserOtpLoginResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserOtpLoginResponseMultiError(errors)
	}
	return nil
}

// UserOtpLoginResponseMultiError is an error wrapping multiple validation
// errors returned by UserOtpLoginResponse.Validate(true) if the designated
// constraints aren't met.
type UserOtpLoginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOtpLoginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOtpLoginResponseMultiError) AllErrors() []error { return m }

// UserOtpLoginResponseValidationError is the validation error returned by
// UserOtpLoginResponse.Validate if the designated constraints aren't met.
type UserOtpLoginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOtpLoginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOtpLoginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOtpLoginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOtpLoginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOtpLoginResponseValidationError) ErrorName() string {
	return "UserOtpLoginResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UserOtpLoginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOtpLoginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOtpLoginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOtpLoginResponseValidationError{}

// Validate checks the field values on UserOtpAuthenticateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UserOtpAuthenticateRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UserOtpAuthenticateRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDeviceId()) < 1 {
		err := UserOtpAuthenticateRequestValidationError{
			field:  "DeviceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := len(m.GetCredentials()); l < 1 || l > 2 {
		err := UserOtpAuthenticateRequestValidationError{
			field:  "Credentials",
			reason: "value must contain between 1 and 2 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetCredentials() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = UserOtpAuthenticateRequestValidationError{
					field:  fmt.Sprintf("Credentials[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return UserOtpAuthenticateRequestMultiError(errors)
	}
	return nil
}

// UserOtpAuthenticateRequestMultiError is an error wrapping multiple
// validation errors returned by UserOtpAuthenticateRequest.Validate(true) if
// the designated constraints aren't met.
type UserOtpAuthenticateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOtpAuthenticateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOtpAuthenticateRequestMultiError) AllErrors() []error { return m }

// UserOtpAuthenticateRequestValidationError is the validation error returned
// by UserOtpAuthenticateRequest.Validate if the designated constraints aren't met.
type UserOtpAuthenticateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOtpAuthenticateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOtpAuthenticateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOtpAuthenticateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOtpAuthenticateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOtpAuthenticateRequestValidationError) ErrorName() string {
	return "UserOtpAuthenticateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UserOtpAuthenticateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOtpAuthenticateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOtpAuthenticateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOtpAuthenticateRequestValidationError{}

// Validate checks the field values on UserOtpAuthenticateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UserOtpAuthenticateResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UserOtpAuthenticateResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RemainingRetryCount

	if v, ok := interface{}(m.GetToken()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = UserOtpAuthenticateResponseValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return UserOtpAuthenticateResponseMultiError(errors)
	}
	return nil
}

// UserOtpAuthenticateResponseMultiError is an error wrapping multiple
// validation errors returned by UserOtpAuthenticateResponse.Validate(true) if
// the designated constraints aren't met.
type UserOtpAuthenticateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOtpAuthenticateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOtpAuthenticateResponseMultiError) AllErrors() []error { return m }

// UserOtpAuthenticateResponseValidationError is the validation error returned
// by UserOtpAuthenticateResponse.Validate if the designated constraints
// aren't met.
type UserOtpAuthenticateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOtpAuthenticateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOtpAuthenticateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOtpAuthenticateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOtpAuthenticateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOtpAuthenticateResponseValidationError) ErrorName() string {
	return "UserOtpAuthenticateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UserOtpAuthenticateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOtpAuthenticateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOtpAuthenticateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOtpAuthenticateResponseValidationError{}

// Validate checks the field values on UserOtpRetryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UserOtpRetryRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UserOtpRetryRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDeviceId()) < 1 {
		err := UserOtpRetryRequestValidationError{
			field:  "DeviceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPhoneNumber()) < 1 {
		err := UserOtpRetryRequestValidationError{
			field:  "PhoneNumber",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UserOtpRetryRequestMultiError(errors)
	}
	return nil
}

// UserOtpRetryRequestMultiError is an error wrapping multiple validation
// errors returned by UserOtpRetryRequest.Validate(true) if the designated
// constraints aren't met.
type UserOtpRetryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOtpRetryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOtpRetryRequestMultiError) AllErrors() []error { return m }

// UserOtpRetryRequestValidationError is the validation error returned by
// UserOtpRetryRequest.Validate if the designated constraints aren't met.
type UserOtpRetryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOtpRetryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOtpRetryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOtpRetryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOtpRetryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOtpRetryRequestValidationError) ErrorName() string {
	return "UserOtpRetryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UserOtpRetryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOtpRetryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOtpRetryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOtpRetryRequestValidationError{}

// Validate checks the field values on UserOtpRetryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UserOtpRetryResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UserOtpRetryResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UserOtpRetryResponseMultiError(errors)
	}
	return nil
}

// UserOtpRetryResponseMultiError is an error wrapping multiple validation
// errors returned by UserOtpRetryResponse.Validate(true) if the designated
// constraints aren't met.
type UserOtpRetryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserOtpRetryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserOtpRetryResponseMultiError) AllErrors() []error { return m }

// UserOtpRetryResponseValidationError is the validation error returned by
// UserOtpRetryResponse.Validate if the designated constraints aren't met.
type UserOtpRetryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserOtpRetryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserOtpRetryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserOtpRetryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserOtpRetryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserOtpRetryResponseValidationError) ErrorName() string {
	return "UserOtpRetryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UserOtpRetryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserOtpRetryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserOtpRetryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserOtpRetryResponseValidationError{}

// Validate checks the field values on RefreshTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in RefreshTokenRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *RefreshTokenRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetRefreshToken()) < 1 {
		err := RefreshTokenRequestValidationError{
			field:  "RefreshToken",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RefreshTokenRequestMultiError(errors)
	}
	return nil
}

// RefreshTokenRequestMultiError is an error wrapping multiple validation
// errors returned by RefreshTokenRequest.Validate(true) if the designated
// constraints aren't met.
type RefreshTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTokenRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTokenRequestMultiError) AllErrors() []error { return m }

// RefreshTokenRequestValidationError is the validation error returned by
// RefreshTokenRequest.Validate if the designated constraints aren't met.
type RefreshTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTokenRequestValidationError) ErrorName() string {
	return "RefreshTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTokenRequestValidationError{}

// Validate checks the field values on RefreshTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in RefreshTokenResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *RefreshTokenResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetToken()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = RefreshTokenResponseValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return RefreshTokenResponseMultiError(errors)
	}
	return nil
}

// RefreshTokenResponseMultiError is an error wrapping multiple validation
// errors returned by RefreshTokenResponse.Validate(true) if the designated
// constraints aren't met.
type RefreshTokenResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTokenResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTokenResponseMultiError) AllErrors() []error { return m }

// RefreshTokenResponseValidationError is the validation error returned by
// RefreshTokenResponse.Validate if the designated constraints aren't met.
type RefreshTokenResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTokenResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTokenResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTokenResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTokenResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTokenResponseValidationError) ErrorName() string {
	return "RefreshTokenResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTokenResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTokenResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTokenResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTokenResponseValidationError{}

// Validate checks the field values on GetJwksRequest with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// GetJwksRequestMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *GetJwksRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetJwksRequestMultiError(errors)
	}
	return nil
}

// GetJwksRequestMultiError is an error wrapping multiple validation errors
// returned by GetJwksRequest.Validate(true) if the designated constraints
// aren't met.
type GetJwksRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetJwksRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetJwksRequestMultiError) AllErrors() []error { return m }

// GetJwksRequestValidationError is the validation error returned by
// GetJwksRequest.Validate if the designated constraints aren't met.
type GetJwksRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetJwksRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetJwksRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetJwksRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetJwksRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetJwksRequestValidationError) ErrorName() string { return "GetJwksRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetJwksRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetJwksRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetJwksRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetJwksRequestValidationError{}

// Validate checks the field values on GetJwksResponse with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in GetJwksResponseMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *GetJwksResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetJwks() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = GetJwksResponseValidationError{
					field:  fmt.Sprintf("Jwks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return GetJwksResponseMultiError(errors)
	}
	return nil
}

// GetJwksResponseMultiError is an error wrapping multiple validation errors
// returned by GetJwksResponse.Validate(true) if the designated constraints
// aren't met.
type GetJwksResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetJwksResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetJwksResponseMultiError) AllErrors() []error { return m }

// GetJwksResponseValidationError is the validation error returned by
// GetJwksResponse.Validate if the designated constraints aren't met.
type GetJwksResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetJwksResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetJwksResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetJwksResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetJwksResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetJwksResponseValidationError) ErrorName() string { return "GetJwksResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetJwksResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetJwksResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetJwksResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetJwksResponseValidationError{}

// Validate checks the field values on JwksItem with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// JwksItemMultiError, or nil if none found. Otherwise, only the first error
// is returned, if any.
func (m *JwksItem) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kid

	// no validation rules for Kty

	// no validation rules for Alg

	// no validation rules for X5C

	if len(errors) > 0 {
		return JwksItemMultiError(errors)
	}
	return nil
}

// JwksItemMultiError is an error wrapping multiple validation errors returned
// by JwksItem.Validate(true) if the designated constraints aren't met.
type JwksItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JwksItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JwksItemMultiError) AllErrors() []error { return m }

// JwksItemValidationError is the validation error returned by
// JwksItem.Validate if the designated constraints aren't met.
type JwksItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JwksItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JwksItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JwksItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JwksItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JwksItemValidationError) ErrorName() string { return "JwksItemValidationError" }

// Error satisfies the builtin error interface
func (e JwksItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJwksItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JwksItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JwksItemValidationError{}

// Validate checks the field values on Token with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// TokenMultiError, or nil if none found. Otherwise, only the first error is
// returned, if any.
func (m *Token) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	// no validation rules for RefreshToken

	if len(errors) > 0 {
		return TokenMultiError(errors)
	}
	return nil
}

// TokenMultiError is an error wrapping multiple validation errors returned by
// Token.Validate(true) if the designated constraints aren't met.
type TokenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenMultiError) AllErrors() []error { return m }

// TokenValidationError is the validation error returned by Token.Validate if
// the designated constraints aren't met.
type TokenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenValidationError) ErrorName() string { return "TokenValidationError" }

// Error satisfies the builtin error interface
func (e TokenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sToken.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenValidationError{}

// Validate checks the field values on AdminLoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in AdminLoginRequestMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *AdminLoginRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return AdminLoginRequestMultiError(errors)
	}
	return nil
}

// AdminLoginRequestMultiError is an error wrapping multiple validation errors
// returned by AdminLoginRequest.Validate(true) if the designated constraints
// aren't met.
type AdminLoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdminLoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdminLoginRequestMultiError) AllErrors() []error { return m }

// AdminLoginRequestValidationError is the validation error returned by
// AdminLoginRequest.Validate if the designated constraints aren't met.
type AdminLoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdminLoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdminLoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdminLoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdminLoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdminLoginRequestValidationError) ErrorName() string {
	return "AdminLoginRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AdminLoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdminLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdminLoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdminLoginRequestValidationError{}

// Validate checks the field values on AdminLoginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in AdminLoginResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *AdminLoginResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetToken()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = AdminLoginResponseValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return AdminLoginResponseMultiError(errors)
	}
	return nil
}

// AdminLoginResponseMultiError is an error wrapping multiple validation errors
// returned by AdminLoginResponse.Validate(true) if the designated constraints
// aren't met.
type AdminLoginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdminLoginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdminLoginResponseMultiError) AllErrors() []error { return m }

// AdminLoginResponseValidationError is the validation error returned by
// AdminLoginResponse.Validate if the designated constraints aren't met.
type AdminLoginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdminLoginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdminLoginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdminLoginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdminLoginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdminLoginResponseValidationError) ErrorName() string {
	return "AdminLoginResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AdminLoginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdminLoginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdminLoginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdminLoginResponseValidationError{}
